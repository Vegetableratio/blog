# 基本使用

## 虚拟`DOM`

虚拟 DOM 的两种创建方式:

1.使用 jsx 创建

```jsx
const VDOM /* 此处一定不要写引号，因为不是字符串 */ = (
  <h1 id="title">
    <span>Hello,React</span>
  </h1>
);
```

2.使用`React`提供的`createElement`方法创建

```js
const VDOM = React.createElement(
  "h1",
  { id: "title" },
  React.createElement("span", {}, "Hello,React")
);
```

关于虚拟`DOM`
-1.本质是`Object`类型的对象（一般对象）
-2.虚拟`DOM`比较“轻”，真实`DOM`比较“重”，因为虚拟`DOM`是`React`内部在用，无需真实`DOM`上那么多的属性。
-3.虚拟`DOM`最终会被`React`转化为真实`DOM`，呈现在页面上。

## `jsx`的基本语法规则

```
1.定义虚拟DOM时，不要写引号。
2.标签中混入JS表达式时要用{}。
3.样式的类名指定不要用class，要用className。
4.内联样式，要用style={{key:value}}的形式去写。
5.只有一个根标签
6.标签必须闭合
7.标签首字母
    (1).若小写字母开头，则将该标签转为html中同名元素，若html中无该标签对应的同名元素，则报错。
    (2).若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。
```

## 组件

1.函数式组件

```jsx
//1.创建函数式组件
function MyComponent() {
  return <h2>我是用函数定义的组件(适用于【简单组件】的定义)</h2>;
}
//2.渲染组件到页面
ReactDOM.render(<MyComponent />, document.getElementById("test"));
/* 
执行了ReactDOM.render(<MyComponent/>.......之后，发生了什么？
    1.React解析组件标签，找到了MyComponent组件。
    2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。
*/
```

2.类组件

```jsx
//1.创建类式组件
class MyComponent extends React.Component {
  render() {
    //render是放在哪里的？—— MyComponent的原型对象上，供实例使用。
    //render中的this是谁？—— MyComponent的实例对象 <=> MyComponent组件实例对象。
    return <h2>我是用类定义的组件(适用于【复杂组件】的定义)</h2>;
  }
}
//2.渲染组件到页面
ReactDOM.render(<MyComponent />, document.getElementById("test"));
/* 
  执行了ReactDOM.render(<MyComponent/>.......之后，发生了什么？
      1.React解析组件标签，找到了MyComponent组件。
      2.发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法。
      3.将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。
*/
```

## 组件实例属性之:`state`

```jsx
//1.创建组件
class Weather extends React.Component {
  //构造器调用几次？ ———— 1次
  constructor(props) {
    console.log("constructor");
    super(props);
    //初始化状态
    this.state = { isHot: false, wind: "微风" };
    //解决changeWeather中this指向问题
    this.changeWeather = this.changeWeather.bind(this);
  }

  //render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数
  render() {
    console.log("render");
    //读取状态
    const { isHot, wind } = this.state;
    return (
      <h1 onClick={this.changeWeather}>
        今天天气很{isHot ? "炎热" : "凉爽"}，{wind}
      </h1>
    );
  }

  //changeWeather调用几次？ ———— 点几次调几次
  changeWeather() {
    //changeWeather放在哪里？ ———— Weather的原型对象上，供实例使用
    //由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用
    //类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined

    console.log("changeWeather");
    //获取原来的isHot值
    const isHot = this.state.isHot;
    //严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。
    this.setState({ isHot: !isHot });
    console.log(this);

    //严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！
    //this.state.isHot = !isHot //这是错误的写法
  }
}
//2.渲染组件到页面
ReactDOM.render(<Weather />, document.getElementById("test"));
```

生产开发中简写:

```jsx
//1.创建组件
class Weather extends React.Component {
  //初始化状态
  state = { isHot: false, wind: "微风" };

  render() {
    const { isHot, wind } = this.state;
    return (
      <h1 onClick={this.changeWeather}>
        今天天气很{isHot ? "炎热" : "凉爽"}，{wind}
      </h1>
    );
  }

  //自定义方法————要用赋值语句的形式+箭头函数
  changeWeather = () => {
    const isHot = this.state.isHot;
    this.setState({ isHot: !isHot });
  };
}
//2.渲染组件到页面
ReactDOM.render(<Weather />, document.getElementById("test"));
```

注意点:

```html
1.render方法中的this为组件实例对象
2.组件中自定义方法中this为undefined解决方式: 
  1)bind改变this指向
  2)使用赋值语句+箭头函数方式
3.状态数据不能直接修改或更新
```
