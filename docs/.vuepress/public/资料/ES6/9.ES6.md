```
ES6
	1.异步方案
	2.新增语法
	3.模块化
```





# 异步方案

问题的提出:回调地狱

```JavaScript
    setTimeout(function (flag) {
        if (flag) {
            console.log("success_1");
            setTimeout(function (flag) {
                if (flag) {
                    console.log("success_2");
                    setTimeout(function (flag) {
                        if (flag) {
                            console.log("success_3");
                            setTimeout(function (flag) {
                                if (flag) {
                                    console.log("success_4");
                                    setTimeout(function (flag) {
                                        if (flag) {
                                            console.log("success_5");
                                        } else {
                                            console.error("error5");
                                        }
                                    }, 1000, true)
                                } else {
                                    console.error("error4");
                                }
                            }, 1000, true)
                        } else {
                            console.error("error3");
                        }
                    }, 1000, true)
                } else {
                    console.error("error2");
                }
            }, 1000, true)
        } else {
            console.error("error1");
        }
    }, 1000, true)
```



案例:移动小球





没有函数名的函数------>能被调用------>说明是浏览器掉用------->这样的函数被称为**回调函数**

同步执行的异步函数:`Arrry.map()`



异步执行的异步函数:定时器

​	

异步执行:同步申明函数,执行代码块放入浏览器线程池,等待JS调用



`() => {}`箭头函数中的`this`与作用域有关,`this`指向上层作用域



为了解决回调地狱提出异步方案

## 1. `Promise`

   - 优点:传值清晰
   - 缺点:回调函数

   

语法:

- `Promise`是构造函数
  - `Promise`的实例对象有三种状态
    1. `pending`   初始状态
    2. `fulfilled`    成功状态
    3. `rejected`   失败状态
- `new Promise((resolve,reject) => {})`    
  - `resolve`和`reject`是`executor`函数的两个参数;当`Promise`构造函数执行时立即调用`executor`函数,`executor`函数在`Promise`构造函数返回新建对象前被调用。
  - `executor`内部通常放入异代码
  - `resolve`和`reject`函数在被调用时分别将Promise的实例对象状态变为:`fulfilled`成功、`rejected`失败.
- `Promise.prototype.then`返回一个新的`Promise`对象;
  - `then`方法返回一个新的`Promise`，而它的行为与`then`中的回调函数的返回值有关!!!
  - 一般手动`return new Promise((resolve,reject)=>{})`
  - 当`executor`中`reject`被调用,那么我们希望后面的代码不被执行,那么可以指定返回一个初始化的Promise实例对象
    - `return new Promise(() => {})`



特点:以同步代码的形式来执行异步代码



面试题:怎么处理异步数值传输?



案例:

```JavaScript
var pinkBall = document.querySelector("#app > .pinkBall");
var redBall = document.querySelector("#app > .redBall");
var greenBall = document.querySelector("#app > .greenBall");


move(pinkBall,50)
	.then(move.bind(redBall,redBall,100))
	.then(move.bind(greenBall,greenBall,150))
	.then(move.bind(greenBall,greenBall,100))
	.then(move.bind(pinkBall,pinkBall,100))

/*move(pinkBall,50)
	.then(()=>{
		move.bind(redBall,redBall,100)
	})*/

//move:动画函数
// ball:谁要滚
// dis: 滚多远
// cb: 滚完谁滚  fn
function move(ball,dis){
	return new Promise((resolve,reject)=>{
		var startLeft = "";
	
		var clearTimer = setInterval(()=>{
			startLeft = ball.offsetLeft;
			if(startLeft === dis){
				clearInterval(clearTimer);
				resolve();
			}else if(startLeft < dis){
				startLeft++;
			}else if(startLeft > dis){
				startLeft--;
			}
			
			ball.style.left = startLeft+"px";
		},1000/60)
	});
}

```



#### `Promise`方法

```
Promise.all(iterable)
	方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。
	
	
Promise.prototype.catch()
	返回一个Promise，并且处理拒绝的情况。它的行为与调用Promise.prototype.then(undefined, onRejected) 相同。
	p.catch(onRejected);

	p.catch(function(reason) {
   		// 拒绝
	});
	
	
Promise.prototype.finally()
	finally() 方法返回一个Promise，在执行then()和catch()后，都会执行finally指定的回调函数。避免同样的语句需要在then()和catch()中各写一次的情况。
	p.finally(onFinally);

    p.finally(function() {
       // 返回状态为(resolved 或 rejected)
    });参数
    
    
Promise.race(iterable)
	返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。
```











---

`Symbol`	基本数据类型  

- 通过`Symbol()`创建一个`Symbol`对象

- 不能通过构造函数形式创建`Symbol`对象,会抛异常

- 每一个`symbol`对象都是唯一的

- `Symbol("syml")`中标识仅为区分

- 一个symbol值存在的意义:作为对象的属性名

  - ```JavaScript
    //Symbol作为属性名
    //第一种
    var school = Symbol();
    var a = {};
    a[school] = "Hello!";
    
    //第二种
    var school = Symbol();
    var a = {
        [school] : "Hello!"
    }
    
    //第三种
    var school = Symbol();
    var a = {};
    Object.defineProperty(a,school,{value : "Hello!"})
    
    
    //以上
    console.log(a[school]);  //Hello!
    ```

对象的属性名有两种类型:

- 字符串类型
- `Symbol`类型





- `Symbol.for()`   有则查找无则添加

- `Symbol.keyFor()`   找键

  - 全局symbol注册表

  - ```JavaScript
    console.log(Symbol.for("foo") === Symbol.for("foo"))
    
    ```

  - 

- `Symbol.iterator`  是一个属性名(Symbol类型的属性);对应的属性值是一个函数(迭代器).函数调用后返回值是一个迭代器对象!



**掌握:**

1. 怎么访问Symbol类型的属性?
2. 对象的属性名有几种类型?







`Iterator` 迭代器,是一个属性

`Symbol.iterator`返回一个symbol类型的值

- 只要有迭代器函数的对象都能使用`for...of`循环
  - `for...of`循环的结果是**属性值**(for...in循环的是属性名)
- 实例对象上默认会有一个迭代器属性,只不过迭代器属性是一个symbol类型
- 调用迭代器属性会返回一个迭代器对象



迭代器协议:

1. 迭代器函数   `arr[Symbol.iterator]`调用返回一个迭代器对象
2. 迭代器函数   ------>   迭代器对象
3. 迭代器对象     `next()`    返回`{value:值 ;done:true/false }`

内置可迭代对象

`String, Array, TypedArray, Map and Set`





问题:为obj创建迭代器(实现迭代器协议)?

---



## 2. `generator`

   - 优点:完全解决回调函数
   - 缺点:数值传递过于复杂

`generator`是一个函数:

- 定义`generator`函数:`function* name(){}` (生成器函数)
- 调用`generator`函数会返回一个生成器对象,符合可迭代协议.
- 调用生成器对象的`next()`方法执行`generator`函数
  - 每次调用`next()`方法,返回一个迭代对象;
  - 每次调用`next()`方法,在yield表达式处暂停,执行yield表达式
    - yield关键字会和一个迭代对象挂钩;迭代对象的value属性是yield表达式的结果
    - yield关键字后面表达式的值 返回给生成器对象的next方法对应的value
    - next 方法对应的value是谁,取决于next 方法执行后在哪个yield表达式上暂停
    - next 方法对应的参数给谁,取决于next 方法执行后在哪个yield表达式上启动
  - 再次调用`next()`方法,在上一个yield表达式处启动,在下一个yield表达式处暂停

数据传递:

```JavaScript
function* test(){
	var y1 = yield  "a";
	console.log(y1)//B
	var y2 = yield 	"b";
	console.log(y2)//C
	var y3 = yield  "c";
	console.log(y3)
}
var it = test();
console.log(it.next("A"));
console.log(it.next("B"));
console.log(it.next("C"));
```



## 3. `async&await`

优点:摆脱了回调,数据传递清晰简单

`async`函数定义:`async function name(){}`

- 调用`async`函数时返回一个`Promise`对象
- async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值
- async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值

`await`

- await  操作符用于等待一个Promise 对象。它只能在async function 中使用。
- await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。
  - 若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行 async function。
  - 若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。

```JavaScript
async function test() {
    var flag = await new Promise((reslove, reject) => {
        setTimeout((flag) => {
            if (flag) {
                console.log("success-1");
                reslove(flag);
            } else {
                console.log("error-1")
                reject();
            }
        }, 1000, true)
    });

    flag = await new Promise((reslove, reject) => {
        setTimeout((flag) => {
            if (flag) {
                console.log("success-2")
                reslove(flag);
            } else {
                console.log("error-2")
                reject("流程2出错");
            }
        }, 1000, !flag)
    });

    await new Promise((reslove, reject) => {
        setTimeout((flag) => {
            if (flag) {
                console.log("success-3")
                reslove();
            } else {
                console.log("error-3")
                reject();
            }
        }, 1000, flag)
    })
}

test();

```



# 块级作用域

函数作用域;全局作用域

`let`命令,用来声明变量

```javascript
{
    let a = 1;
}
//let声明的变量仅在当前块级作用域内有效
```

1. for循环,不会污染全局作用域
2. 解决了闭包
3. 不存在重复申明-->报错
4. 不存在声明的提升



`const`命令,用来声明常量,值不可被修改



let/const命令声明的全局变量,不属于顶层作用于的属性





# 解构赋值

```JavaScript
//数组的解构复制
let [a,b,c] = [1,2,3];
let [[],[,,[,,[a]]]] = [[1,2],[2,3,[4,5,[6]]]]
//只要等号两边的结构相同,左边的变量就会赋于相应的值;不成功为undefined;

//...运算符只能出现在解构赋值的最后!结构成数组;没有值即为空数组!
let [head,...tail] = [1,2,3,4]//head [1]  ; tail [2,3,4]
let [a,b,...z] = ["a"]	//a a   b undefined    z []


//默认值
let [a,b = "b"] = [1,undefined];
//匹配值为undefined时表示匹配不成功;b为默认值
```

```JavaScript
//对象的解构赋值
//a,b表示匹配模式;A,B表示变量
let {a:A,b:B} = {a:"lishi",b:18};
console.log(A, B);


//当变量名和属性名一样时可以省略
let {a,b} = {a:"lishi",b:18};

//还能上对象的原型链
let obj = {
    name:"lishi",
    age:18
}
let {name,age} = obj;
let {toString} = obj;

//注意点!
//{}会被认为代码块被执行;
{name} = {name:"lishi"}
//防止出现此类错误可以添加()运算符
({name} = {name:"lishi"})

//面试题
{} == []
[] == {}
{}+[]//0
[]+{}//[object Object]

//嵌套
var obj={
	name:"xfz",
	wife:[{
		name:"凤姐",
		son:[{
			name:"小明"
		},{
			name:"大明"
		}]
	},{
		name:"如花",
		son:{
			name:"十月"
		}
	}]
}
//let  {name:fname,wife:[{name:wname,son:[{name:sname1},{name:sname2}]}]} = obj;

let  {name,wife:[{name,son:[{name},{name}]}]} = obj; //报错 重复声明

```

```JavaScript
//字符串的结构赋值
let [a,b,c,d,e] = "hello"


//数字和布尔值   如果是以上两中类型数值则会先转换成对象
let {toString: s} = 123;
let {toString: s} = true;
//由于结构赋值是解构对象的属性,所以数字和布尔值解构赋值为其原型链上的属性

/*
解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。
由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。
*/
```

```JavaScript
//函数参数的解构赋值
    function add([x, y]) {
        return x + y;
    }

    add([1, 2]); // 3
```





# 字符串、函数、对象、数组

```JavaScript
//字符串的扩展
//模板字符串
var obj={
	msg:"app",
	flag:true
}//后台数据

app.innerHTML =`我是一个${obj.msg};${obj.flag?"1":"2"}`;
```



```JavaScript
//对象的扩展
//对象的简洁写法
let name = "damu";
let arr = "age";

let obj = {
    [Symbol()]: "symbol",
    [arr + "2"]: 18, //表达式作为变量名,需放到括号内
    name,  //name:name,
    coding() {//coding:function(){}
        console.log("----")
    }
};
console.log(obj.age2);
obj.coding();
```



```JavaScript
//函数的扩展

//默认参数:为函数的参数设置值


/*
ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面
一旦设置了参数的默认值，函数进行初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的
*/
function log(x, y = 'World') {
  console.log(x, y);
}
log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello
log('Hello', undefined) // Hello World
```



# Class

```
1.没有提升
2.constructor 构造器
3.只能通过new 调用
4.静态方法(static)
	如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用;即"静态方法"
	如果静态方法包含this关键字，这个this指向是类，而不是实例
	
5.getter&setter
	与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。
6.静态属性&实例属性
	Class 内部只有静态方法，没有静态属性。
	
7.继承(extends)
	class Point {}
	class ColorPoint extends Point {}
	
	注意:
		a.父类的静态方法，会被子类继承
		b.继承
```

```JavaScript
class Person{
    constructor(x,y) { //构造器  不写constructor会主动创建constructor,return this
        this.x = x;
        this.y = y;
    }
}
let p = new Person("A","B"); //this --> p
```

```JavaScript
class Person{
    constructor(x,y) { 
        this.x = x;
        this.y = y;
    }
    //方法之间不需要逗号分隔
    eat(){	//挂靠为Person的显示原型的方法
       console.log("eat") 
    }
    static fn(){	//静态方法
        console.log("fn")
    }
}
let p = new Person("A","B"); 
Person.fn()
```

```JavaScript
class Person{
    constructor(x,y) { 
        this.x = x;
        this.y = y;
    }
    get prop() {
    	return 'getter';
 	}
  	set prop(value) {
    	console.log('setter: '+value);
  	}
}
let p = new Person("A","B"); 
Person.fn()
```







# 4.模块化

```
早期代码的问题
	1.无法解决文件的依赖问题
	2.全局函数命名冲突
	3.IIFE
```



```
模块化方案:
	1.common--服务器端
	2.AMD-客户端
	3.CMD-客户端
```



## 模块化方案1-sea.js

```
解决了依赖问题
解决了命名冲突

没有解决模块化合并
	可以合并,过程复杂
```



```JavaScript
//在index.html页面中引入sea.js
<script src="assets/sea-modules/seajs/1.3.0/sea.js"></script>


<script>
  // 加载入口模块
  //a,b,c分别是接受到的模块:module.exports
  seajs.use(['./js/a.js','./js/b.js','./js/c.js'],function(a,b,c){
        a.index1();
        console.log(b.a);
        c.index3();
	})
</script>


//书写模块代码
//common 对应模块的 module.exports;即依赖关系所暴露的功能
define(function(require, exports, module) {
  // 获取依赖，此模块 只依赖common.js
  var common = require("./common.js");

  // 下面是核心功能代码
  function Spinning1() { 
        console.log("A")
  }

  function Spinning2() { 
		console.log("B")
  }


  // 模块的暴露(3种方式)
      /*注意!:
      exports 和 module.exports 指向同一个引用(深入体会一下内存图)
      */
  //1.给exports添加属性
  exports.Spinning1 = Spinning1;
    
  //2.给module.exports赋值
  module.exports = Spinning1;
    
 
  //3.给module.exports赋值一个对象
  module.exports = {
      Spinning1:Spinning1,
      Spinning2:Spinning2
  };
})



```



## 模块化方案2-commonjs

```
1.每个文件是一个模块，有自己的作用域
2.在模块内部  module变量代表模块本身
3.module.exports属性代表模块对外的接口

```



```
解决了依赖问题
解决了命名冲突
解决了模块化合并
```

```JavaScript
//common.jc
function common(){
    return "common";
}
module.exports = common;//对外提供接口(3种方式,同sea.js)

-----------------------------------------------------------------------
//c.js
var common = require('./common.js')
function index1(){
    console.log( "index1 " + common() +" from a" )
}
function index2(){
    console.log( "index2" + common() +" from a")
}
function index3(){
    console.log( "index3" + common() +" from a")
}

// 对外提供接口
module.exports = {
    index1:index1,
    index2:index2,
    index3:index3
}
-------------------------------------------------------------------
//b.js
var common = require("./common.js");
function index1(){
	console.log( "index1 " + common() +" from b" )
}
function index2(){
	console.log( "index2" + common() +" from b")
}
function index3(){
	console.log( "index3" + common() +" from b")
}

var a =1;
//exports 和 module.exports 指向同一个引用
exports.index1=index1;
exports.index2=index2;
exports.index3=index3;
exports.a = a;

----------------------------------------------------------------
//index.js
var a = require("./js/a.js");
var b = require("./js/b.js");

a.index1();
b.index2();
----------------------------------------------------------------
//通过browserify打包

```

```
安装browserify -g全局
	npm install browserify -g
查看安装目录
	npm config get prefix
是否安装成功/查看所有命令
	browserify -h
编译,进入相应目录进行操作			-o:输出  目录
	browserify ./编译文件所在目录.js -o disk/index.js
	
```



## 模块化方案3-ES6

```
ES6模块化方案,可以静态分析,编译阶段即可解析分析
	import
		import+代码块
	export
		export+代码块
```

```JavaScript
//静态

//common.js
export function common(){
    return "common";
}
  
//a.js
import {common} from "./common.js"

export function index1(){
	console.log( "index1 " + common() +" from a" )
}
export let a ="a from a"

//index.js
import * as a from "./a.js"
a.index1();
console.log(a.a);

//使用webpack进行模块化合并
```
```JavaScript
//动态

//common.js
export default function common(){
    return "common";
}
  
//a.js
import common from "./common.js"

function index1(){
	console.log( "index1 " + common() +" from a" )
}

export let a ="a from a"
export default{
    index1,
    a
}

//index.js
import a from "./a.js"
a.index1();
console.log(a.a);

//使用webpack进行模块化合并
```

```
//安装webpack
npm webpack@3.10.0 -g 
//更改源
npm config set registry https://registry.npm.taobao.org
```



注意点:

```
1.很多环境下打包后的代码是运行在严格模式下的;模块内部代码最好遵循严格模式
	https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode
2.暴露出的模块不能去修改
3.ES6的模块化时静默分析的   暴露出的模块只能放在当前作用域的最顶层
4.每个模块对应的作用域是局部(函数)作用域
```









复习:

```
模块化：
    commonjs 是node社区为node量身定做的模块化方案
        AMD:require.js(战略性放弃)
        CMD:seajs(玉伯)
            定义模块:define
            暴露模块：
                module.exports
                    随意玩
                exports
                    只能添加属性
                    不能重新赋值（赋值-->值与引用的问题）
            依赖：require
                require("路径")拿到的就是module.exports
                路径：
                    模块的相对路径参照与自身
                    普通js文件参照于引用者
                    相对路径一定要写 ./
            命名冲突：命名空间
            seajs的模块化合并（大问题）
    commonjs
            commonjs的模块化合并（borwserify）
    es6
        es6的模块化合并（webpack@3.10.0）
        import  {xxx}  from "路径"
            xxx是什么？
                对象
                     export var a ={name:"damu"};
                函数
                    export function name(){}
                基本数据类型的值
                    export var a =1;
                类
                    export class name{};
        import  * as xxx from "路径"
            xxx是什么？
                无论是什么暴露都是对象
        import  xxx from "路径"
                对象
                    export default {};
                函数
                    export default function name(){}
                基本数据类型的值
                    export default var a =1;
                类
                    export default class name{};
                    
        export  代码块
```



思考

```
ES6比commonjs优秀在哪?
	
什么叫静态分析?
	ES5解释型语言;ES6可以编译,可以确定模块与模块之间的关系
```













